---
interface Props {
  /** Number of items to show initially */
  initialCount?: number;
  /** Number of items to load on each scroll */
  loadCount?: number;
}

const { initialCount = 6, loadCount = 6 } = Astro.props;
---

<div class="infinite-scroll-container" data-initial-count={initialCount} data-load-count={loadCount}>
  <div class="infinite-scroll-grid">
    <slot />
  </div>
  <div class="infinite-scroll-sentinel" aria-hidden="true"></div>
  <div class="infinite-scroll-loader" aria-live="polite">
    <!-- Skeleton Cards -->
    <div class="skeleton-grid">
      <div class="skeleton-card">
        <div class="skeleton-image"></div>
        <div class="skeleton-content">
          <div class="skeleton-meta"></div>
          <div class="skeleton-title"></div>
          <div class="skeleton-desc"></div>
          <div class="skeleton-footer">
            <div class="skeleton-avatar"></div>
            <div class="skeleton-badge"></div>
          </div>
        </div>
      </div>
      <div class="skeleton-card">
        <div class="skeleton-image"></div>
        <div class="skeleton-content">
          <div class="skeleton-meta"></div>
          <div class="skeleton-title"></div>
          <div class="skeleton-desc"></div>
          <div class="skeleton-footer">
            <div class="skeleton-avatar"></div>
            <div class="skeleton-badge"></div>
          </div>
        </div>
      </div>
      <div class="skeleton-card">
        <div class="skeleton-image"></div>
        <div class="skeleton-content">
          <div class="skeleton-meta"></div>
          <div class="skeleton-title"></div>
          <div class="skeleton-desc"></div>
          <div class="skeleton-footer">
            <div class="skeleton-avatar"></div>
            <div class="skeleton-badge"></div>
          </div>
        </div>
      </div>
    </div>
  </div>
  <div class="infinite-scroll-end" aria-live="polite">
    <span>You've reached the end!</span>
  </div>
</div>

<style>
  @reference "tailwindcss";

  .infinite-scroll-container {
    @apply w-full;
  }

  .infinite-scroll-grid {
    @apply grid gap-6;
    grid-template-columns: repeat(auto-fill, minmax(320px, 1fr));
  }

  .infinite-scroll-grid > :global(*) {
    display: none;
  }

  .infinite-scroll-grid > :global(.visible) {
    display: block;
  }

  .infinite-scroll-sentinel {
    @apply h-1 w-full;
  }

  .infinite-scroll-loader {
    @apply hidden py-8;
  }

  .infinite-scroll-loader.loading {
    @apply block;
  }

  /* Skeleton Styles */
  .skeleton-grid {
    @apply grid gap-6;
    grid-template-columns: repeat(auto-fill, minmax(320px, 1fr));
  }

  .skeleton-card {
    @apply overflow-hidden rounded-xl;
    background-color: var(--color-surface);
    border: 1px solid var(--color-border);
  }

  .skeleton-image {
    @apply aspect-video w-full;
    background: linear-gradient(90deg, var(--color-bg) 25%, var(--color-border) 50%, var(--color-bg) 75%);
    background-size: 200% 100%;
    animation: shimmer 1.5s infinite;
  }

  .skeleton-content {
    @apply flex flex-col gap-3 p-5;
  }

  .skeleton-meta {
    @apply h-4 w-32 rounded;
    background: linear-gradient(90deg, var(--color-bg) 25%, var(--color-border) 50%, var(--color-bg) 75%);
    background-size: 200% 100%;
    animation: shimmer 1.5s infinite;
  }

  .skeleton-title {
    @apply h-6 w-3/4 rounded;
    background: linear-gradient(90deg, var(--color-bg) 25%, var(--color-border) 50%, var(--color-bg) 75%);
    background-size: 200% 100%;
    animation: shimmer 1.5s infinite;
    animation-delay: 0.1s;
  }

  .skeleton-desc {
    @apply h-4 w-full rounded;
    background: linear-gradient(90deg, var(--color-bg) 25%, var(--color-border) 50%, var(--color-bg) 75%);
    background-size: 200% 100%;
    animation: shimmer 1.5s infinite;
    animation-delay: 0.2s;
  }

  .skeleton-footer {
    @apply flex items-center justify-between pt-2;
  }

  .skeleton-avatar {
    @apply h-7 w-24 rounded-full;
    background: linear-gradient(90deg, var(--color-bg) 25%, var(--color-border) 50%, var(--color-bg) 75%);
    background-size: 200% 100%;
    animation: shimmer 1.5s infinite;
    animation-delay: 0.3s;
  }

  .skeleton-badge {
    @apply h-6 w-16 rounded-full;
    background: linear-gradient(90deg, var(--color-bg) 25%, var(--color-border) 50%, var(--color-bg) 75%);
    background-size: 200% 100%;
    animation: shimmer 1.5s infinite;
    animation-delay: 0.4s;
  }

  @keyframes shimmer {
    0% {
      background-position: 200% 0;
    }
    100% {
      background-position: -200% 0;
    }
  }

  .infinite-scroll-end {
    @apply hidden items-center justify-center py-8 text-sm;
    color: var(--color-muted);
  }

  .infinite-scroll-end.show {
    @apply flex;
  }
</style>

<script>
  class InfiniteScroll {
    private container: HTMLElement;
    private grid: HTMLElement;
    private sentinel: HTMLElement;
    private loader: HTMLElement;
    private endMessage: HTMLElement;
    private items: HTMLElement[];
    private visibleCount: number;
    private loadCount: number;
    private observer: IntersectionObserver | null = null;
    private isLoading: boolean = false;

    constructor(container: HTMLElement) {
      this.container = container;
      this.grid = container.querySelector(".infinite-scroll-grid")!;
      this.sentinel = container.querySelector(".infinite-scroll-sentinel")!;
      this.loader = container.querySelector(".infinite-scroll-loader")!;
      this.endMessage = container.querySelector(".infinite-scroll-end")!;

      this.items = Array.from(this.grid.children) as HTMLElement[];
      this.visibleCount = parseInt(container.dataset.initialCount || "6", 10);
      this.loadCount = parseInt(container.dataset.loadCount || "6", 10);

      this.init();
    }

    private init(): void {
      // Show initial items
      this.showItems(0, this.visibleCount);

      // Check if we already have all items visible
      if (this.visibleCount >= this.items.length) {
        this.showEndMessage();
        return;
      }

      // Set up Intersection Observer
      this.observer = new IntersectionObserver(
        (entries) => {
          entries.forEach((entry) => {
            if (entry.isIntersecting && !this.isLoading) {
              this.loadMore();
            }
          });
        },
        {
          rootMargin: "100px",
        },
      );

      this.observer.observe(this.sentinel);
    }

    private showItems(start: number, end: number): void {
      for (let i = start; i < Math.min(end, this.items.length); i++) {
        this.items[i].classList.add("visible");
      }
    }

    private loadMore(): void {
      if (this.visibleCount >= this.items.length) {
        this.showEndMessage();
        return;
      }

      this.isLoading = true;
      this.loader.classList.add("loading");

      // Simulate a small delay for smooth UX
      setTimeout(() => {
        const newCount = Math.min(this.visibleCount + this.loadCount, this.items.length);
        this.showItems(this.visibleCount, newCount);
        this.visibleCount = newCount;

        this.loader.classList.remove("loading");
        this.isLoading = false;

        if (this.visibleCount >= this.items.length) {
          this.showEndMessage();
        }
      }, 300);
    }

    private showEndMessage(): void {
      if (this.observer) {
        this.observer.disconnect();
      }
      this.endMessage.classList.add("show");
    }
  }

  // Initialize all infinite scroll containers
  document.querySelectorAll(".infinite-scroll-container").forEach((container) => {
    new InfiniteScroll(container as HTMLElement);
  });
</script>
